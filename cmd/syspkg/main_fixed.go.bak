// syspkg - Fixed implementation combining unified interface backend with original CLI behavior
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"sort"
	"strings"
	"sync"
	"time"

	"github.com/bluet/syspkg/manager"

	// Import all available package managers
	_ "github.com/bluet/syspkg/manager/apt"
)

const (
	version = "2.1.0-fixed"
	usage   = `syspkg - Universal Package Manager (Fixed)

USAGE:
    syspkg <command> [options] [packages...]

COMMANDS:
    search <query>        Search for packages across all managers (default)
    list [filter]         List packages (installed, upgradable, all)
    install <packages>    Install packages
    remove <packages>     Remove packages
    info <package>        Show package information
    update               Update package lists
    upgrade [packages]    Upgrade packages
    clean                Clean package cache
    autoremove           Remove orphaned packages
    verify <packages>    Verify package integrity
    status               Show package manager status
    managers             List available package managers

OPTIONS:
    # Your original superior filtering approach
    --apt, --yum, --snap, --flatpak    Use only specific manager(s)

    # Performance options (realistic improvements)
    --parallel                         Use parallel queries (default for multi-manager)
    --sequential                       Use sequential queries

    # Display options
    --summary                          Condensed view (top results per manager)
    --details                          Full view (all results) - default

    # Standard options
    -m, --manager TYPE   Use specific manager type (system, language, etc.)
    -n, --name NAME      Use specific manager by name
    -d, --dry-run        Show what would be done without executing
    -v, --verbose        Show detailed output
    -q, --quiet          Minimal output
    -j, --json           Output in JSON format
    -y, --yes            Assume yes to all prompts
    -h, --help           Show this help
    --version            Show version

EXAMPLES:
    # Multi-manager discovery (your original superior behavior)
    syspkg search vim                    # Search ALL managers, rich output
    syspkg search vim --summary          # Top results per manager

    # User filtering (your original superior control)
    syspkg search vim --apt              # Only APT (fast)
    syspkg search vim --apt --snap       # Only APT + Snap

    # Performance options
    syspkg search vim --parallel         # Parallel queries (default)
    syspkg search vim --sequential       # Sequential like original
`
)

type FixedConfig struct {
	// Manager Selection (your original superior approach)
	ManagerFilters map[string]bool // apt, yum, snap, flatpak, etc.
	UseAllManagers bool            // Default: true

	// Performance (realistic improvements)
	UseParallel bool // Default: true for multi-manager

	// Display (honest progressive disclosure)
	ShowSummary bool // Show top N per manager
	ShowDetails bool // Show all results (default)

	// Standard options
	Manager     string
	ManagerType string
	DryRun      bool
	Verbose     bool
	Quiet       bool
	JSON        bool
	AssumeYes   bool
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println(usage)
		os.Exit(1)
	}

	config := parseFixedArgs()
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
	defer cancel()

	// Execute command with fixed multi-manager approach
	err := executeFixedCommand(ctx, config)
	if err != nil {
		if !config.Quiet {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		}
		os.Exit(1)
	}
}

func parseFixedArgs() *FixedConfig {
	config := &FixedConfig{
		ManagerFilters: make(map[string]bool),
		UseAllManagers: true,  // Your superior default
		UseParallel:    true,  // Realistic performance improvement
		ShowDetails:    true,  // Your superior comprehensive default
	}

	args := os.Args[1:]

	for i := 0; i < len(args); i++ {
		arg := args[i]

		switch arg {
		// Manager selection (your original superior approach)
		case "--apt":
			config.ManagerFilters["apt"] = true
			config.UseAllManagers = false
		case "--yum":
			config.ManagerFilters["yum"] = true
			config.UseAllManagers = false
		case "--snap":
			config.ManagerFilters["snap"] = true
			config.UseAllManagers = false
		case "--flatpak":
			config.ManagerFilters["flatpak"] = true
			config.UseAllManagers = false
		case "--all":
			config.UseAllManagers = true
			config.ManagerFilters = make(map[string]bool) // Clear filters

		// Performance options
		case "--parallel":
			config.UseParallel = true
		case "--sequential":
			config.UseParallel = false

		// Display options
		case "--summary":
			config.ShowSummary = true
			config.ShowDetails = false
		case "--details":
			config.ShowSummary = false
			config.ShowDetails = true

		// Standard options
		case "-n", "--name":
			if i+1 < len(args) {
				config.Manager = args[i+1]
				config.UseAllManagers = false
				i++
			}
		case "-v", "--verbose":
			config.Verbose = true
		case "-q", "--quiet":
			config.Quiet = true
		case "-j", "--json":
			config.JSON = true
		case "-h", "--help":
			fmt.Println(usage)
			os.Exit(0)
		case "--version":
			fmt.Printf("syspkg version %s (fixed)\n", version)
			os.Exit(0)
		}
	}

	return config
}

// Restore your original superior manager selection logic
func getSelectedManagers(registry *manager.Registry, config *FixedConfig) map[string]manager.PackageManager {
	available := registry.GetAvailable()

	// Single manager specified
	if config.Manager != "" {
		if pm, exists := available[config.Manager]; exists {
			return map[string]manager.PackageManager{config.Manager: pm}
		}
		return nil
	}

	// All managers (your original superior default)
	if config.UseAllManagers {
		return available
	}

	// Filtered managers (your original superior user control)
	result := make(map[string]manager.PackageManager)
	for name, enabled := range config.ManagerFilters {
		if enabled {
			if pm, exists := available[name]; exists {
				result[name] = pm
			}
		}
	}

	return result
}

func executeFixedCommand(ctx context.Context, config *FixedConfig) error {
	args := getCommandArgs()
	if len(args) == 0 {
		return fmt.Errorf("no command specified")
	}

	command := args[0]

	registry := manager.GetGlobalRegistry()
	managers := getSelectedManagers(registry, config)

	if len(managers) == 0 {
		return fmt.Errorf("no package managers available")
	}

	opts := &manager.Options{
		DryRun:    config.DryRun,
		Verbose:   config.Verbose,
		Quiet:     config.Quiet,
		AssumeYes: config.AssumeYes,
	}

	switch command {
	case "search":
		if len(args) < 2 {
			return fmt.Errorf("search requires a query")
		}
		return handleFixedSearch(ctx, managers, args[1:], config, opts)

	case "managers":
		return handleFixedManagers(config)

	// Add other commands...
	default:
		return fmt.Errorf("command '%s' not implemented in fixed version", command)
	}
}

// Fixed multi-manager search with your original superior behavior
func handleFixedSearch(ctx context.Context, managers map[string]manager.PackageManager, query []string, config *FixedConfig, opts *manager.Options) error {
	startTime := time.Now()

	if !config.Quiet {
		managerNames := make([]string, 0, len(managers))
		for name := range managers {
			managerNames = append(managerNames, name)
		}
		sort.Strings(managerNames)

		if len(managers) == 1 {
			fmt.Printf("Searching for '%s' using %s...\n", strings.Join(query, " "), managerNames[0])
		} else {
			fmt.Printf("Searching for '%s' across %d managers (%s)...\n",
				strings.Join(query, " "), len(managers), strings.Join(managerNames, ", "))
		}
	}

	// Search strategy based on config
	var results []SearchResult
	if config.UseParallel && len(managers) > 1 {
		results = searchParallel(ctx, managers, query, opts)
	} else {
		results = searchSequential(ctx, managers, query, opts)
	}

	totalDuration := time.Since(startTime)

	if config.JSON {
		return outputJSON(results, totalDuration, query)
	}

	// Display results like your original implementation
	return displayFixedResults(results, totalDuration, config)
}

// Fixed display that matches your original rich output
func displayFixedResults(results []SearchResult, duration time.Duration, config *FixedConfig) error {
	totalCount := 0
	for _, result := range results {
		totalCount += len(result.Packages)
	}

	if !config.Quiet && !config.ShowSummary {
		fmt.Printf("Found %d packages across %d managers (%.2fs):\n\n",
			totalCount, len(results), duration.Seconds())
	}

	for _, mgr := range results {
		if mgr.Error != nil {
			fmt.Printf("Error searching %s: %v\n", mgr.ManagerName, mgr.Error)
			continue
		}

		if len(mgr.Packages) == 0 {
			if !config.Quiet && !config.ShowSummary {
				fmt.Printf("No results from %s\n", mgr.ManagerName)
			}
			continue
		}

		if config.ShowSummary {
			displaySummaryForManager(mgr, config)
		} else {
			displayDetailedForManager(mgr, config)
		}
	}

	return nil
}

// Summary view (honest progressive disclosure)
func displaySummaryForManager(mgr SearchResult, config *FixedConfig) {
	fmt.Printf("📦 %s (%d packages)\n", strings.ToUpper(mgr.ManagerName), len(mgr.Packages))

	// Show top 3 results with rich information
	count := len(mgr.Packages)
	if count > 3 {
		count = 3
	}

	for i := 0; i < count; i++ {
		pkg := mgr.Packages[i]
		fmt.Printf("  ✓ %s %s - %s (%s)\n",
			pkg.Name, pkg.Version, truncateString(pkg.Description, 50), pkg.Status)
	}

	if len(mgr.Packages) > 3 {
		fmt.Printf("  • %d more packages...\n", len(mgr.Packages)-3)
	}
	fmt.Println()
}

// Detailed view (your original comprehensive approach)
func displayDetailedForManager(mgr SearchResult, config *FixedConfig) {
	fmt.Printf("Found results for %s (%d packages, %.2fs):\n",
		mgr.ManagerName, len(mgr.Packages), mgr.Duration.Seconds())

	for _, pkg := range mgr.Packages {
		if config.Quiet {
			fmt.Printf("%s\n", pkg.Name)
		} else {
			// Rich output like your original: manager: name [version] (status)
			fmt.Printf("%s: %s [%s] (%s)\n",
				mgr.ManagerName, pkg.Name, pkg.Version, pkg.Status)
		}
	}
	fmt.Println()
}

func handleFixedManagers(config *FixedConfig) error {
	registry := manager.GetGlobalRegistry()
	managers := registry.GetAvailable()

	if config.JSON {
		type ManagerInfo struct {
			Name      string `json:"name"`
			Type      string `json:"type"`
			Available bool   `json:"available"`
		}

		var infos []ManagerInfo
		for name, pm := range managers {
			infos = append(infos, ManagerInfo{
				Name:      name,
				Type:      pm.GetType(),
				Available: pm.IsAvailable(),
			})
		}

		return json.NewEncoder(os.Stdout).Encode(infos)
	}

	fmt.Println("Available Package Managers:")
	for name, pm := range managers {
		status := "❌"
		if pm.IsAvailable() {
			status = "✅"
		}
		fmt.Printf("  %s %-10s (%s)\n", status, name, pm.GetType())
	}

	return nil
}

// Parallel search implementation (realistic performance improvement)
func searchParallel(ctx context.Context, managers map[string]manager.PackageManager, query []string, opts *manager.Options) []SearchResult {
	results := make([]SearchResult, 0, len(managers))
	resultChan := make(chan SearchResult, len(managers))
	var wg sync.WaitGroup

	// Launch parallel searches
	for name, pm := range managers {
		wg.Add(1)
		go func(managerName string, packageManager manager.PackageManager) {
			defer wg.Done()

			startTime := time.Now()
			packages, err := packageManager.Search(ctx, query, opts)
			duration := time.Since(startTime)

			resultChan <- SearchResult{
				ManagerName: managerName,
				Packages:    packages,
				Error:       err,
				Duration:    duration,
			}
		}(name, pm)
	}

	// Wait for completion
	go func() {
		wg.Wait()
		close(resultChan)
	}()

	// Collect results
	for result := range resultChan {
		results = append(results, result)
	}

	// Sort for consistent output
	sort.Slice(results, func(i, j int) bool {
		return results[i].ManagerName < results[j].ManagerName
	})

	return results
}

// Sequential search (your original approach)
func searchSequential(ctx context.Context, managers map[string]manager.PackageManager, query []string, opts *manager.Options) []SearchResult {
	results := make([]SearchResult, 0, len(managers))

	// Sort manager names for consistent output
	names := make([]string, 0, len(managers))
	for name := range managers {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		pm := managers[name]
		startTime := time.Now()
		packages, err := pm.Search(ctx, query, opts)
		duration := time.Since(startTime)

		results = append(results, SearchResult{
			ManagerName: name,
			Packages:    packages,
			Error:       err,
			Duration:    duration,
		})
	}

	return results
}

// Helper types and functions
type SearchResult struct {
	ManagerName string                `json:"manager"`
	Packages    []manager.PackageInfo `json:"packages"`
	Error       error                 `json:"error,omitempty"`
	Duration    time.Duration         `json:"duration"`
}

func truncateString(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}

func outputJSON(results []SearchResult, duration time.Duration, query []string) error {
	output := struct {
		Results    []SearchResult `json:"results"`
		Duration   time.Duration  `json:"total_duration"`
		QueryTerms []string       `json:"query_terms"`
	}{
		Results:    results,
		Duration:   duration,
		QueryTerms: query,
	}
	return json.NewEncoder(os.Stdout).Encode(output)
}

func getCommandArgs() []string {
	args := os.Args[1:]
	var result []string

	// Skip flags and extract command + args
	for i := 0; i < len(args); i++ {
		arg := args[i]

		// Skip flags that take values
		if (arg == "-n" || arg == "--name") && i+1 < len(args) {
			i++ // Skip the value too
			continue
		}

		// Skip single flags
		if strings.HasPrefix(arg, "-") {
			continue
		}

		// This is a command or argument
		result = append(result, arg)
	}

	return result
}
